{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AppsDock","title":"Home"},{"location":"developer/","text":"AppsDock Developer Documentation This documentation is about the development of AppsDock, a PHP based enterprise platform for business applications. By reading this documentation you will learn the concept, composition and the development aspects of the AppsDock platform. You will be able to maintain, develop, adapt and extend the platform by writing apps, extension and plugins. Concept The AppsDock platform provides an universal foundation which is able to run a large scale of business apps.","title":"Introduction"},{"location":"developer/#appsdock-developer-documentation","text":"This documentation is about the development of AppsDock, a PHP based enterprise platform for business applications. By reading this documentation you will learn the concept, composition and the development aspects of the AppsDock platform. You will be able to maintain, develop, adapt and extend the platform by writing apps, extension and plugins.","title":"AppsDock Developer Documentation"},{"location":"developer/#concept","text":"The AppsDock platform provides an universal foundation which is able to run a large scale of business apps.","title":"Concept"},{"location":"developer/API/REST/","text":"REST API Endpunkte Um f\u00fcr eine App eigene REST API Endpunkte zu erstellen, legt man eine Klasse an, welche vom AppsDock\\Core\\Contracts\\App\\Application\\RestAPIController erbt. In dieser werden \u00fcber Annotation Attribute die einzelnen Endpunkte definiert. Der Zugriff auf Endpunkte kann mittels Richtlinien abgesichert werden. Methoden class BookRestAPI extends RestAPIController { #[API('GET', '/books', 'book.list')] public function listBooks(): JsonResponse { ... } #[API('GET', '/books/{id}', 'book.get')] public function getBook(string $bookId): JsonResponse { ... } #[API('POST', '/books', 'book.create')] public function createBook(): JsonResponse { ... } #[API('DELETE', '/books/{id}', 'book.delete')] public function deleteBook(string $bookId): JsonResponse { ... } } Parameter Datentyp Standardwert Erforderlich Beschreibung 1 String|String[] - \u2714 Methoden: DELETE, GET, HEAD, PATCH, POST und PUT. 2 String - \u2714 Route: Valide URL. 3 String - \u2714 Eindeutiger Name in Domain-Schreibweise. 4 Integer 1 \u2718 API-Version. \u2714 Ja \u2718 Nein R\u00fcckgabewerte Der R\u00fcckgabewert eines Endpunkts muss immer vom Datentyp AppsDock\\Core\\Http\\JsonResponse sein. Um eine allgemeine R\u00fcckmeldung zu erzeugen, kann die Methode createResponse verwendet werden. $this->createResponse( int $statusCode = 200, array $data = [], array $headers = [] ); Soll ein HTTP-Status-Code zur\u00fcckgegeben werden, kann die Methode createStatusResponse verwendet werden. $this->createStatusResponse( int $statusCode, string $message = null, array $headers = [] ); Sollen Daten zur\u00fcckgegeben werden, kann die Methode createDataResponse verwendet werden. $this->createDataResponse( ReadModel|ReadModelCollection|null $data, int $statusCode = 200, array $headers = [] );","title":"REST API"},{"location":"developer/API/REST/#rest-api","text":"","title":"REST API"},{"location":"developer/API/REST/#endpunkte","text":"Um f\u00fcr eine App eigene REST API Endpunkte zu erstellen, legt man eine Klasse an, welche vom AppsDock\\Core\\Contracts\\App\\Application\\RestAPIController erbt. In dieser werden \u00fcber Annotation Attribute die einzelnen Endpunkte definiert. Der Zugriff auf Endpunkte kann mittels Richtlinien abgesichert werden.","title":"Endpunkte"},{"location":"developer/API/REST/#methoden","text":"class BookRestAPI extends RestAPIController { #[API('GET', '/books', 'book.list')] public function listBooks(): JsonResponse { ... } #[API('GET', '/books/{id}', 'book.get')] public function getBook(string $bookId): JsonResponse { ... } #[API('POST', '/books', 'book.create')] public function createBook(): JsonResponse { ... } #[API('DELETE', '/books/{id}', 'book.delete')] public function deleteBook(string $bookId): JsonResponse { ... } } Parameter Datentyp Standardwert Erforderlich Beschreibung 1 String|String[] - \u2714 Methoden: DELETE, GET, HEAD, PATCH, POST und PUT. 2 String - \u2714 Route: Valide URL. 3 String - \u2714 Eindeutiger Name in Domain-Schreibweise. 4 Integer 1 \u2718 API-Version. \u2714 Ja \u2718 Nein","title":"Methoden"},{"location":"developer/API/REST/#ruckgabewerte","text":"Der R\u00fcckgabewert eines Endpunkts muss immer vom Datentyp AppsDock\\Core\\Http\\JsonResponse sein. Um eine allgemeine R\u00fcckmeldung zu erzeugen, kann die Methode createResponse verwendet werden. $this->createResponse( int $statusCode = 200, array $data = [], array $headers = [] ); Soll ein HTTP-Status-Code zur\u00fcckgegeben werden, kann die Methode createStatusResponse verwendet werden. $this->createStatusResponse( int $statusCode, string $message = null, array $headers = [] ); Sollen Daten zur\u00fcckgegeben werden, kann die Methode createDataResponse verwendet werden. $this->createDataResponse( ReadModel|ReadModelCollection|null $data, int $statusCode = 200, array $headers = [] );","title":"R\u00fcckgabewerte"},{"location":"developer/apps/introduction/","text":"Apps","title":"Introduction"},{"location":"developer/apps/introduction/#apps","text":"","title":"Apps"},{"location":"developer/architecture/styles/","text":"Style Layers","title":"Style Layers"},{"location":"developer/architecture/styles/#style-layers","text":"","title":"Style Layers"},{"location":"developer/architecture/backend/introduction/","text":"Backend Architecture AppsDock is a docker container based php application which runs primary on a customized php-fpm image. The AppsDock Application Server is a bundle and eco system of multiple docker container based services. The setup and definition of all services is defined is a docker-compose.yml file.","title":"Introduction"},{"location":"developer/architecture/backend/introduction/#backend-architecture","text":"AppsDock is a docker container based php application which runs primary on a customized php-fpm image. The AppsDock Application Server is a bundle and eco system of multiple docker container based services. The setup and definition of all services is defined is a docker-compose.yml file.","title":"Backend Architecture"},{"location":"developer/gettingstarted/environment/","text":"Developer Environment Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Environment"},{"location":"developer/gettingstarted/environment/#developer-environment","text":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Developer Environment"},{"location":"developer/gettingstarted/introduction/","text":"Getting Started Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Concept Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Prerequisites Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Introduction"},{"location":"developer/gettingstarted/introduction/#getting-started","text":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Getting Started"},{"location":"developer/gettingstarted/introduction/#concept","text":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Concept"},{"location":"developer/gettingstarted/introduction/#prerequisites","text":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Prerequisites"},{"location":"developer/gettingstarted/setup/","text":"Project Setup Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Setup"},{"location":"developer/gettingstarted/setup/#project-setup","text":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.","title":"Project Setup"},{"location":"developer/gettingstarted/xdebug/","text":"Phpstorm Xdebug-Einrichtung Deployment-Konfiguration des Vagrant Box vollenden \u00dcberpr\u00fcfung der Einstellung siehe Screenshot [step1] Server einrichten [step2] Wichtig! Das Mapping Local-Path zu Remot Path (Bild Project Files) Debugkonfiguration [step3] Run -> Debug -> Edit Configurations -> Defaults aufklappen -> Php Remote Debug Dort den in Schritt2 erstellten Server ausw\u00e4hlen. Listening aktivieren Run -> Start Listening for Php Connections Dann Breakpoint setzen in Storm -> und Seite im Browser aufrufen et voila!!!","title":"Phpstorm Xdebug-Einrichtung"},{"location":"developer/gettingstarted/xdebug/#phpstorm-xdebug-einrichtung","text":"Deployment-Konfiguration des Vagrant Box vollenden \u00dcberpr\u00fcfung der Einstellung siehe Screenshot [step1]","title":"Phpstorm Xdebug-Einrichtung"},{"location":"developer/gettingstarted/xdebug/#server-einrichten-step2","text":"Wichtig! Das Mapping Local-Path zu Remot Path (Bild Project Files)","title":"Server einrichten [step2]"},{"location":"developer/gettingstarted/xdebug/#debugkonfiguration-step3","text":"Run -> Debug -> Edit Configurations -> Defaults aufklappen -> Php Remote Debug Dort den in Schritt2 erstellten Server ausw\u00e4hlen.","title":"Debugkonfiguration [step3]"},{"location":"developer/gettingstarted/xdebug/#listening-aktivieren","text":"Run -> Start Listening for Php Connections Dann Breakpoint setzen in Storm -> und Seite im Browser aufrufen et voila!!!","title":"Listening aktivieren"},{"location":"developer/guidelines/version-control/","text":"Version control (Git) Repository Commit Messages A commit message must consist of the following parts: FunctionID This identifier should contain the project identifier. This project identifier are defined for each project / app in jira. ADK Identifier: CORE, DEV, SYS, ADK, FT, CM, DM * CORE = core folder * SYS = system folder * DEV = dev folder * FE = frontend folder * ADK = bin,www folder and all what is not suitable * CM = Configuration Management * DOC = Documentation Management Label Choose one of the labels that fits the change in your commit. #INIT \u2013 Initialize a new repo or release repro:documentation / configuration \u2026 archetype:jar / war / ear / pom / zip \u2026 version:version #IMPLEMENT \u2013 Implement a new Function, Class, Component or Use case function:clazz create:clazz / compontent use-case:usecaze #CHANGE \u2013 Change a exists function,class or component function:clazz refactor:clazz / function / component / use-case... #EXTEND \u2013 Extend a exists function,class or component function:clazz attach:clazz / component / use-case ... #BUGFIX priority:critical / medium / low / design #REVIEW \u2013 Quality refactor:function analyze:quality migrate:function format:source #RELEASE version:version #REVERT \u2013 Revert a Revision commit:id #BRANCH create:name stash:branch #MERGE from:branch to:branch #CLOSE branch:name Task-ID This ID is the issue ID generated by JIRA.","title":"Version Control"},{"location":"developer/guidelines/version-control/#version-control-git","text":"","title":"Version control (Git)"},{"location":"developer/guidelines/version-control/#repository-commit-messages","text":"A commit message must consist of the following parts: FunctionID This identifier should contain the project identifier. This project identifier are defined for each project / app in jira. ADK Identifier: CORE, DEV, SYS, ADK, FT, CM, DM * CORE = core folder * SYS = system folder * DEV = dev folder * FE = frontend folder * ADK = bin,www folder and all what is not suitable * CM = Configuration Management * DOC = Documentation Management Label Choose one of the labels that fits the change in your commit. #INIT \u2013 Initialize a new repo or release repro:documentation / configuration \u2026 archetype:jar / war / ear / pom / zip \u2026 version:version #IMPLEMENT \u2013 Implement a new Function, Class, Component or Use case function:clazz create:clazz / compontent use-case:usecaze #CHANGE \u2013 Change a exists function,class or component function:clazz refactor:clazz / function / component / use-case... #EXTEND \u2013 Extend a exists function,class or component function:clazz attach:clazz / component / use-case ... #BUGFIX priority:critical / medium / low / design #REVIEW \u2013 Quality refactor:function analyze:quality migrate:function format:source #RELEASE version:version #REVERT \u2013 Revert a Revision commit:id #BRANCH create:name stash:branch #MERGE from:branch to:branch #CLOSE branch:name Task-ID This ID is the issue ID generated by JIRA.","title":"Repository Commit Messages"},{"location":"developer/identity-access/Identit%C3%A4ten/","text":"Identit\u00e4ten Zu den Identit\u00e4ten z\u00e4hlen Benutzer, Gruppen und Rollen. Benutzer Der Benutzer wird f\u00fcr die Identifizierung und Autorisierung einer Entit\u00e4t verwendet. Gruppen Benutzer k\u00f6nnen zu einer Gruppe zusammengefasst werden. Ein Benutzer kann mehreren Gruppen angeh\u00f6ren. Durch eine Gruppe k\u00f6nnen mehreren Benutzern Rollen zugewiesen werden. Rollen Rollen sind Identit\u00e4ten, welche Benutzern und Gruppen zugewiesen werden k\u00f6nnen. Mittels der Rolle werden die Berechtigungen identifiziert. Einer Rolle k\u00f6nnen eine oder mehrere Richtlinien zugewiesen werden.","title":"Identit\u00e4ten"},{"location":"developer/identity-access/Identit%C3%A4ten/#identitaten","text":"Zu den Identit\u00e4ten z\u00e4hlen Benutzer, Gruppen und Rollen.","title":"Identit\u00e4ten"},{"location":"developer/identity-access/Identit%C3%A4ten/#benutzer","text":"Der Benutzer wird f\u00fcr die Identifizierung und Autorisierung einer Entit\u00e4t verwendet.","title":"Benutzer"},{"location":"developer/identity-access/Identit%C3%A4ten/#gruppen","text":"Benutzer k\u00f6nnen zu einer Gruppe zusammengefasst werden. Ein Benutzer kann mehreren Gruppen angeh\u00f6ren. Durch eine Gruppe k\u00f6nnen mehreren Benutzern Rollen zugewiesen werden.","title":"Gruppen"},{"location":"developer/identity-access/Identit%C3%A4ten/#rollen","text":"Rollen sind Identit\u00e4ten, welche Benutzern und Gruppen zugewiesen werden k\u00f6nnen. Mittels der Rolle werden die Berechtigungen identifiziert. Einer Rolle k\u00f6nnen eine oder mehrere Richtlinien zugewiesen werden.","title":"Rollen"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/","text":"Richtlinien und Berechtigungen Berechtigung Eine Berechtigung besteht aus einer oder mehreren Richtlinien. Beispiel: Die Berechtigung DMS-Anwender hat das unbestimmte Recht innerhalb des gesamten DMS zu lesen und das bestimmte Recht in den eigenen Ordnern zu schreiben. Richtlinie Aktion Rolle Ressource Effekt Lesen com.appsdock.dms.action:read UUID * ALLOW Schreiben com.appsdock.dms.action:write UUID UUID ALLOW Richtlinie Eine Richtlinie besteht aus der Aktion, der Rolle, der Ressource und dem Effekt. Aktion Aktionen werden von den Apps definiert. Beispiel: Die DMS-App definiert die Aktion Ordner anlegen . Rolle Pro Richtlinie muss exakt eine Rolle zugewiesen werden. Ressource Eine Ressource kann bestimmt oder unbestimmt sein. Unbestimmte Ressourcen werden mittels des * definiert. Effekt Der Effekt ist entweder Erlauben oder Verbieten . Berechtigungssteuerung Der Berechtigungssteuerung wird die Aktion als erster Parameter und der Kontext als zweiter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId() ); Bei einer bestimmten Ressource wird deren UUID als dritter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId ); Alternativ kann ein Standardwert als vierter Parameter angegeben werden. Dieser wird nur zur\u00fcckgegeben, wenn keine Richtlinie existiert. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId, $default ); REST API Berechtigungen werden als Methoden-Attribut oder alternativ als Klassen-Attribut definiert. Berechtigungen als Klassen-Attribut gelten f\u00fcr alle Funktionen innerhalb der Klasse. Unbestimmte Ressource #[Permission('read')] Bestimmte Ressource \u00dcber den zweiten Parameter kann die UUID der Ressource angegeben werden. Die UUID kann bspw. im Kontext der REST API mittels eines Routing-Parameters dynamisch \u00fcbergeben werden. #[Permission('read', 'id')] Alternativer Kontext \u00dcber den dritten Parameter kann ein alternativer Kontext angegeben werden, damit man Richtlinien aus anderen Apps pr\u00fcfen kann. #[Permission('read', 'id', 'com.appsdock')] Mehrere Richtlinien Mehrere Richtlinien k\u00f6nnen direkt als Array \u00fcbergeben werden. #[Permission(['read', 'write', 'delete'])] Bei bestimmten Ressourcen oder einem alternativen Kontext m\u00fcssen diese separat aufgef\u00fchrt werden. #[Permission(['read', 'write'])] #[Permission('delete', 'id')] #[Permission('administrate', context: 'com.appsdock')] Klassen-Attribut #[Permission('read')] class DMS { ... } Methoden-Attribut #[Permission('write')] public function write(string $text): bool { ... } Sonderfall: \u00f6ffentlicher Zugriff Der \u00f6ffentliche Zugriff auf Klassen-Ebene kann von Richtlinien auf Methoden-Ebene \u00fcberschrieben werden. Wiederum ignoriert der \u00f6ffentliche Zugriff auf Methoden-Ebene alle zus\u00e4tzlichen Richtlinien. #[PublicAccess]","title":"Richtlinien und Berechtigungen"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#richtlinien-und-berechtigungen","text":"","title":"Richtlinien und Berechtigungen"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#berechtigung","text":"Eine Berechtigung besteht aus einer oder mehreren Richtlinien. Beispiel: Die Berechtigung DMS-Anwender hat das unbestimmte Recht innerhalb des gesamten DMS zu lesen und das bestimmte Recht in den eigenen Ordnern zu schreiben. Richtlinie Aktion Rolle Ressource Effekt Lesen com.appsdock.dms.action:read UUID * ALLOW Schreiben com.appsdock.dms.action:write UUID UUID ALLOW","title":"Berechtigung"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#richtlinie","text":"Eine Richtlinie besteht aus der Aktion, der Rolle, der Ressource und dem Effekt.","title":"Richtlinie"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#aktion","text":"Aktionen werden von den Apps definiert. Beispiel: Die DMS-App definiert die Aktion Ordner anlegen .","title":"Aktion"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#rolle","text":"Pro Richtlinie muss exakt eine Rolle zugewiesen werden.","title":"Rolle"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#ressource","text":"Eine Ressource kann bestimmt oder unbestimmt sein. Unbestimmte Ressourcen werden mittels des * definiert.","title":"Ressource"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#effekt","text":"Der Effekt ist entweder Erlauben oder Verbieten .","title":"Effekt"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#berechtigungssteuerung","text":"Der Berechtigungssteuerung wird die Aktion als erster Parameter und der Kontext als zweiter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId() ); Bei einer bestimmten Ressource wird deren UUID als dritter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId ); Alternativ kann ein Standardwert als vierter Parameter angegeben werden. Dieser wird nur zur\u00fcckgegeben, wenn keine Richtlinie existiert. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId, $default );","title":"Berechtigungssteuerung"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#rest-api","text":"Berechtigungen werden als Methoden-Attribut oder alternativ als Klassen-Attribut definiert. Berechtigungen als Klassen-Attribut gelten f\u00fcr alle Funktionen innerhalb der Klasse.","title":"REST API"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#unbestimmte-ressource","text":"#[Permission('read')]","title":"Unbestimmte Ressource"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#bestimmte-ressource","text":"\u00dcber den zweiten Parameter kann die UUID der Ressource angegeben werden. Die UUID kann bspw. im Kontext der REST API mittels eines Routing-Parameters dynamisch \u00fcbergeben werden. #[Permission('read', 'id')]","title":"Bestimmte Ressource"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#alternativer-kontext","text":"\u00dcber den dritten Parameter kann ein alternativer Kontext angegeben werden, damit man Richtlinien aus anderen Apps pr\u00fcfen kann. #[Permission('read', 'id', 'com.appsdock')]","title":"Alternativer Kontext"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#mehrere-richtlinien","text":"Mehrere Richtlinien k\u00f6nnen direkt als Array \u00fcbergeben werden. #[Permission(['read', 'write', 'delete'])] Bei bestimmten Ressourcen oder einem alternativen Kontext m\u00fcssen diese separat aufgef\u00fchrt werden. #[Permission(['read', 'write'])] #[Permission('delete', 'id')] #[Permission('administrate', context: 'com.appsdock')]","title":"Mehrere Richtlinien"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#klassen-attribut","text":"#[Permission('read')] class DMS { ... }","title":"Klassen-Attribut"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#methoden-attribut","text":"#[Permission('write')] public function write(string $text): bool { ... }","title":"Methoden-Attribut"},{"location":"developer/identity-access/Richtlinien%20und%20Berechtigungen/#sonderfall-offentlicher-zugriff","text":"Der \u00f6ffentliche Zugriff auf Klassen-Ebene kann von Richtlinien auf Methoden-Ebene \u00fcberschrieben werden. Wiederum ignoriert der \u00f6ffentliche Zugriff auf Methoden-Ebene alle zus\u00e4tzlichen Richtlinien. #[PublicAccess]","title":"Sonderfall: \u00f6ffentlicher Zugriff"},{"location":"developer/identity-access/authentication/","text":"AppsDock Authentication Service The AppsDock application server provides a build in authentication and authorization service to secure the resources. This topic provides an overview how to authenticate and access secured resources of the application server. Basics The request of resources from AppsDock application server requires an access token from the AppsDock authentication service. To obtain an access token, there must be a registered auth client at AppsDock identity management which must be used when requesting the auth endpoints with client credentials from your web or app application. Auth Client The access of auth API endpoints requires at least one registered auth client at AppsDock identity management. The AppsDock identity management can register multiple auth client with different configurations which can be used by different applications. Each auth client has its own credentials (client id or client id with secret) which must be used when requesting the auth API. The credentials can be attached as basic base64 encoded Auhtorization header or as query parameter at request uri. Access token The access token is issued by the AppsDock authentication service and contains secured information (claims) about the actual operator. The token also contains information which are used to validate/authenticate the operator and verify that it has the required permissions / is authorized to perform the operation. Access tokens have to be attached to each request that intents to access secured resources of the AppsDock application server. The transport must be always over a secured channel like HTTPS. An access token issued by the AppsDock authentication service looks like the following example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c To attach the access token, you must set the access token as bearer type in the Authorization header. Authentication The AppsDock authentication service provides an API for token and cookie based authentication management which includes the following operations: Endpoint Operation /auth/token Authentication with email/username and password /auth/token/refresh Session/Token refresh via refresh token or cookie /auth/revoke Revoke auth session via refresh token or cookie The AppsDock authentication service supports both token and cookie based authentication flows. Token Based Auth The token based authentication is used by confidential clients like mobile apps, which are capable of storing the refresh token securely. To obtain an access and refresh token, you have to send a request with the auth client credentials as authorization header to the token endpoint. POST https : // domain . com / auth / token Content - Type : application / json Authrorization : Basic WIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF { \"email\" : \"jon@doe.com\" , \"password\" : \"xxxxx\" } The response contains the access/refresh token and additional information about the access token. { \"expires_in\" : 180 , \"expires_at\" : 1595453215 , \"token_type\" : \"bearer\" , \"access_token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0......\" , \"refresh_token\" : \"xwRJSMxNTE2MjMeKKF2QiwibmFtZSIfwpMeJf6Ik\" } The access token must be attached as bearer token in Authorization header on each request of secured resources. The refresh token is used to refresh the access token when it expires and obtain a new access token. Refresh token storage The refresh token must be stored securely and should not be accessible by the client user. Do not store the refresh token into any kind of client side storages of web applications like local or session store nor into cookies. Cookie Based Auth ...... doc comming { \"expires_in\" : 180 , \"expires_at\" : 1595453215 } A cookie based client response only the expiry information about the current auth session, and uses an secured httpsonly cookie to store the auth session information on client side. The auth cookie issued by the cookie based confidential client has also a short lifetime like the access token, so it must be refreshed to keep the auth session valid. Public clients Public auth clients are currently not supported by the AppsDock authentication service! Refreshing ..","title":"Authentication"},{"location":"developer/identity-access/authentication/#appsdock-authentication-service","text":"The AppsDock application server provides a build in authentication and authorization service to secure the resources. This topic provides an overview how to authenticate and access secured resources of the application server.","title":"AppsDock Authentication Service"},{"location":"developer/identity-access/authentication/#basics","text":"The request of resources from AppsDock application server requires an access token from the AppsDock authentication service. To obtain an access token, there must be a registered auth client at AppsDock identity management which must be used when requesting the auth endpoints with client credentials from your web or app application.","title":"Basics"},{"location":"developer/identity-access/authentication/#auth-client","text":"The access of auth API endpoints requires at least one registered auth client at AppsDock identity management. The AppsDock identity management can register multiple auth client with different configurations which can be used by different applications. Each auth client has its own credentials (client id or client id with secret) which must be used when requesting the auth API. The credentials can be attached as basic base64 encoded Auhtorization header or as query parameter at request uri.","title":"Auth Client"},{"location":"developer/identity-access/authentication/#access-token","text":"The access token is issued by the AppsDock authentication service and contains secured information (claims) about the actual operator. The token also contains information which are used to validate/authenticate the operator and verify that it has the required permissions / is authorized to perform the operation. Access tokens have to be attached to each request that intents to access secured resources of the AppsDock application server. The transport must be always over a secured channel like HTTPS. An access token issued by the AppsDock authentication service looks like the following example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c To attach the access token, you must set the access token as bearer type in the Authorization header.","title":"Access token"},{"location":"developer/identity-access/authentication/#authentication","text":"The AppsDock authentication service provides an API for token and cookie based authentication management which includes the following operations: Endpoint Operation /auth/token Authentication with email/username and password /auth/token/refresh Session/Token refresh via refresh token or cookie /auth/revoke Revoke auth session via refresh token or cookie The AppsDock authentication service supports both token and cookie based authentication flows.","title":"Authentication"},{"location":"developer/identity-access/authentication/#token-based-auth","text":"The token based authentication is used by confidential clients like mobile apps, which are capable of storing the refresh token securely. To obtain an access and refresh token, you have to send a request with the auth client credentials as authorization header to the token endpoint. POST https : // domain . com / auth / token Content - Type : application / json Authrorization : Basic WIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF { \"email\" : \"jon@doe.com\" , \"password\" : \"xxxxx\" } The response contains the access/refresh token and additional information about the access token. { \"expires_in\" : 180 , \"expires_at\" : 1595453215 , \"token_type\" : \"bearer\" , \"access_token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0......\" , \"refresh_token\" : \"xwRJSMxNTE2MjMeKKF2QiwibmFtZSIfwpMeJf6Ik\" } The access token must be attached as bearer token in Authorization header on each request of secured resources. The refresh token is used to refresh the access token when it expires and obtain a new access token. Refresh token storage The refresh token must be stored securely and should not be accessible by the client user. Do not store the refresh token into any kind of client side storages of web applications like local or session store nor into cookies.","title":"Token Based Auth"},{"location":"developer/identity-access/authentication/#cookie-based-auth","text":"...... doc comming { \"expires_in\" : 180 , \"expires_at\" : 1595453215 } A cookie based client response only the expiry information about the current auth session, and uses an secured httpsonly cookie to store the auth session information on client side. The auth cookie issued by the cookie based confidential client has also a short lifetime like the access token, so it must be refreshed to keep the auth session valid. Public clients Public auth clients are currently not supported by the AppsDock authentication service!","title":"Cookie Based Auth"},{"location":"developer/identity-access/authentication/#refreshing","text":"..","title":"Refreshing"},{"location":"developer/identity-access/authorization/","text":"Authorization","title":"Authorization"},{"location":"developer/identity-access/authorization/#authorization","text":"","title":"Authorization"},{"location":"developer/identity-access/intro/","text":"Identity and Access Management","title":"Introduction"},{"location":"developer/identity-access/intro/#identity-and-access-management","text":"","title":"Identity and Access Management"},{"location":"developer/process/generation/","text":"Development Process (App und Aggregate Generierung) Generieren der Model-Json-Files Das in Schritt 1 installierte Plugin kann in MW unter \"Tools -> Utilities -> Business-Model-Json-Generator\" ausgef\u00fchrt werden. Der Speicherort der Dateien kann x-beliebig sein. Das bumo-Script, welches die PHP-Klassen, App und Aufbau-Logik generiert, kann nun auf die Json-Dateien angewandt werden. Allgemeines Anzeige der Hilfe ./bumo help Auflistung der vorhandenen, einzel ausf\u00fchrbaren Commands ./bumo list App erzeugen ./bumo app:init appname oder die Kurzform ./bumo a:i appname Aggregate erzeugen ./bumo app:generate-aggregate appname aggregate oder in Kurzform ./bumo a:g appname aggregate Letzteres kann mit der -f oder --file Option so ausgef\u00fchrt werden das man den Ort der Json Dateien als Pfad angeben kann, wenn man die BU-Json-Dateien nicht im Projektverzeichnis unter apps/appname/setup/defs abgespeichert hat, was der Standard Suchpfad ist bei Angabe von Option --f ohne Pfad. Allgemeiner Standardpfad ist getcwd. Wenn die App jedoch noch nicht existiert, kann sie zum einem \u00fcber den init Befehl angelegt werden, muss jedoch nicht da auch der Generate-Befehl das Projektverzeichnis anlegt. Bsp.: ./bumo a:g task Task Alle Commands sind einzeln ausf\u00fchrbar, man kann also z.B. nur die Handler neu generieren lassen mit dem Befehl: ./bumo command:handler task Task Empfohlenes Vorgehen Im Verzeichnis dev/workbench_plugins liegt eine Example.json welche f\u00fcr den Guide hier Verwendung findet Vorab (Globalen Link f\u00fcr codeception setzen, um es von jedem Verzeichnis ausf\u00fchren zu k\u00f6nnen): ln -s PROJECT_ROOT/vendor/bin/codecept /usr/local/bin/codecept 1) App erzeugen (Dadurch wird das Testverzeichnis gebootstrapped und die App wird in der Datenbank registriert) ./bumo a:i example 2) Aggregate generieren ./bumo a:g example Example -f ./workbench_plugins 3) Erzeugen der Datenbanktabelle Vorab Ausf\u00fchrungssql ansehen (wird noch nichts erzeugt) ./bumo schema create example --dump Erzeugen ./bumo schema create example 4) Testausf\u00fchren (Erzeugen eines Examples) cd PROJECT_ROOT codecept run api -c apps/example/tests Wenn der Test positiv ist, existiert nun ein Objekt in der Datenbank. Es wurde erfolgreich erstellt und wieder ausgelesen. Aktualisierung 1) Aggregate regenerieren ./bumo a:g example Example -f ./workbench_plugins 2) \u00c4nderung Mergen Unter dev/.appsdock existiert jetzt ein Verzeichniss mit dem Aggregatenamen \"example\", worin einmal eine Patch-Datei und die ver\u00e4nderte Code-Datei daf\u00fcr liegen, letztere in PHP-Storm ausw\u00e4hlen und mit \"Compare with...\" mit der Originalen vergleichen und manuell mergen. 3) Aktualisierung der Datenbanktabelle Vorab Ausf\u00fchrungssql ansehen (wird noch nichts erzeugt) ./bumo schema update example --dump Aktualisieren ./bumo schema update example 4) Testausf\u00fchren (Erzeugen eines Examples) cd PROJECT_ROOT codecept run api -c apps/example/tests Wenn der Test positiv ist, existiert nun ein Objekt in der Datenbank. Es wurde erfolgreich erstellt und wieder ausgelesen. Datenbanktabelle seeden 1) Fixture anlegen Im Ordner tests/Fixture (wenn nicht vorhanden anlegen) eine Klasse erstellen mit der Namenskonvention \"AggregateFixture\" und diese von BaseFixture erben lassen. 2) Seeden ./bumo db:seed example Example Komplexeres Beispiel mit Reference: Stubs Generierung 1) Subs generieren ./bumo stub:generate path outpath Appsdock Console nutzen (schnelle \u00dcberpr\u00fcfung von Funktionen,History,Autocomplete) 1) Console starten Alle Klassen werden direkt ohne Namespace in die Consolensession geladen und s\u00e4mtliche Operationen k\u00f6nnen darauf ausgef\u00fchrt werden. ./bumo vsh In dem Beispiel, wurde einfach das ValueObject TravelDates aus der Parking App mit 'new' erzeugt und eine Get-Funktion darauf ausgef\u00fchrt. Datenbank Yaml-Dateien generieren 1) Yaml generieren Die Yaml-Dateien findet man dann im apps/example/setup/db Verzeichnis. ./bumo db:yml example Example Troubleshoots Bekannte Fehlerf\u00e4lle: 1) Schema update: MysqlPlatform wird nicht unterst\u00fctzt, damit auch f\u00fcr Mysql das Schema aktualisiert werden kann, muss in Doctrine in der Klasse SchemaTool Zeile 357 auskommentiert werden. 2) Identity.xml ValueObject definition not found Hotfix: bei dem sich handelten Aggregate, eine Fake xml Datei (AggregateId.xml) in dem orm xml VO Verzeichniss erstellen. Dabei den Dateinamen nat\u00fcrlich ersetzen mit dem aus der Fehlermeldung.","title":"Code Generation"},{"location":"developer/process/generation/#development-process-app-und-aggregate-generierung","text":"","title":"Development Process (App und Aggregate Generierung)"},{"location":"developer/process/generation/#generieren-der-model-json-files","text":"Das in Schritt 1 installierte Plugin kann in MW unter \"Tools -> Utilities -> Business-Model-Json-Generator\" ausgef\u00fchrt werden. Der Speicherort der Dateien kann x-beliebig sein. Das bumo-Script, welches die PHP-Klassen, App und Aufbau-Logik generiert, kann nun auf die Json-Dateien angewandt werden.","title":"Generieren der Model-Json-Files"},{"location":"developer/process/generation/#allgemeines","text":"Anzeige der Hilfe ./bumo help Auflistung der vorhandenen, einzel ausf\u00fchrbaren Commands ./bumo list App erzeugen ./bumo app:init appname oder die Kurzform ./bumo a:i appname Aggregate erzeugen ./bumo app:generate-aggregate appname aggregate oder in Kurzform ./bumo a:g appname aggregate Letzteres kann mit der -f oder --file Option so ausgef\u00fchrt werden das man den Ort der Json Dateien als Pfad angeben kann, wenn man die BU-Json-Dateien nicht im Projektverzeichnis unter apps/appname/setup/defs abgespeichert hat, was der Standard Suchpfad ist bei Angabe von Option --f ohne Pfad. Allgemeiner Standardpfad ist getcwd. Wenn die App jedoch noch nicht existiert, kann sie zum einem \u00fcber den init Befehl angelegt werden, muss jedoch nicht da auch der Generate-Befehl das Projektverzeichnis anlegt. Bsp.: ./bumo a:g task Task Alle Commands sind einzeln ausf\u00fchrbar, man kann also z.B. nur die Handler neu generieren lassen mit dem Befehl: ./bumo command:handler task Task","title":"Allgemeines"},{"location":"developer/process/generation/#empfohlenes-vorgehen","text":"Im Verzeichnis dev/workbench_plugins liegt eine Example.json welche f\u00fcr den Guide hier Verwendung findet Vorab (Globalen Link f\u00fcr codeception setzen, um es von jedem Verzeichnis ausf\u00fchren zu k\u00f6nnen): ln -s PROJECT_ROOT/vendor/bin/codecept /usr/local/bin/codecept 1) App erzeugen (Dadurch wird das Testverzeichnis gebootstrapped und die App wird in der Datenbank registriert) ./bumo a:i example 2) Aggregate generieren ./bumo a:g example Example -f ./workbench_plugins 3) Erzeugen der Datenbanktabelle Vorab Ausf\u00fchrungssql ansehen (wird noch nichts erzeugt) ./bumo schema create example --dump Erzeugen ./bumo schema create example 4) Testausf\u00fchren (Erzeugen eines Examples) cd PROJECT_ROOT codecept run api -c apps/example/tests Wenn der Test positiv ist, existiert nun ein Objekt in der Datenbank. Es wurde erfolgreich erstellt und wieder ausgelesen.","title":"Empfohlenes Vorgehen"},{"location":"developer/process/generation/#aktualisierung","text":"1) Aggregate regenerieren ./bumo a:g example Example -f ./workbench_plugins 2) \u00c4nderung Mergen Unter dev/.appsdock existiert jetzt ein Verzeichniss mit dem Aggregatenamen \"example\", worin einmal eine Patch-Datei und die ver\u00e4nderte Code-Datei daf\u00fcr liegen, letztere in PHP-Storm ausw\u00e4hlen und mit \"Compare with...\" mit der Originalen vergleichen und manuell mergen. 3) Aktualisierung der Datenbanktabelle Vorab Ausf\u00fchrungssql ansehen (wird noch nichts erzeugt) ./bumo schema update example --dump Aktualisieren ./bumo schema update example 4) Testausf\u00fchren (Erzeugen eines Examples) cd PROJECT_ROOT codecept run api -c apps/example/tests Wenn der Test positiv ist, existiert nun ein Objekt in der Datenbank. Es wurde erfolgreich erstellt und wieder ausgelesen.","title":"Aktualisierung"},{"location":"developer/process/generation/#datenbanktabelle-seeden","text":"1) Fixture anlegen Im Ordner tests/Fixture (wenn nicht vorhanden anlegen) eine Klasse erstellen mit der Namenskonvention \"AggregateFixture\" und diese von BaseFixture erben lassen. 2) Seeden ./bumo db:seed example Example Komplexeres Beispiel mit Reference:","title":"Datenbanktabelle seeden"},{"location":"developer/process/generation/#stubs-generierung","text":"1) Subs generieren ./bumo stub:generate path outpath","title":"Stubs Generierung"},{"location":"developer/process/generation/#appsdock-console-nutzen-schnelle-uberprufung-von-funktionenhistoryautocomplete","text":"1) Console starten Alle Klassen werden direkt ohne Namespace in die Consolensession geladen und s\u00e4mtliche Operationen k\u00f6nnen darauf ausgef\u00fchrt werden. ./bumo vsh In dem Beispiel, wurde einfach das ValueObject TravelDates aus der Parking App mit 'new' erzeugt und eine Get-Funktion darauf ausgef\u00fchrt.","title":"Appsdock Console nutzen (schnelle \u00dcberpr\u00fcfung von Funktionen,History,Autocomplete)"},{"location":"developer/process/generation/#datenbank-yaml-dateien-generieren","text":"1) Yaml generieren Die Yaml-Dateien findet man dann im apps/example/setup/db Verzeichnis. ./bumo db:yml example Example","title":"Datenbank Yaml-Dateien generieren"},{"location":"developer/process/generation/#troubleshoots","text":"Bekannte Fehlerf\u00e4lle: 1) Schema update: MysqlPlatform wird nicht unterst\u00fctzt, damit auch f\u00fcr Mysql das Schema aktualisiert werden kann, muss in Doctrine in der Klasse SchemaTool Zeile 357 auskommentiert werden. 2) Identity.xml ValueObject definition not found Hotfix: bei dem sich handelten Aggregate, eine Fake xml Datei (AggregateId.xml) in dem orm xml VO Verzeichniss erstellen. Dabei den Dateinamen nat\u00fcrlich ersetzen mit dem aus der Fehlermeldung.","title":"Troubleshoots"},{"location":"developer/process/introduction/","text":"Development Process (Erzeugung eines Business Models) Utensilien 1) Mysql Workbench 2) Mysql Workbench Plugin \"Business-Model-Json-Generator\" 3) bumogen Legende Abk\u00fcrzungen MW - Mysql Workbench BC - Bounded Context ETC - Event Timeline Context CTC - Command/Query Timeline Context BU - Business Model ER - Entity Relation AR - Aggregate Root VO - Value Object CE - Child Entity Was muss ich vorab tun? 1) Plugin installieren \u00fcber MW -> Scripting -> Install Plugin (das Plugin liegt im Projektverzeichnis unter dev/workbench_plugins 2) Benutzerdefiniertentyp ValueObject anlegen unter MW -> Model -> User Defined Types... mit dem Namen ValueObject rest ist egal. Erstellen eines BU-Models (obligatorisch) Nachdem anlegen eines Models in MW, erzeugt man zun\u00e4chst einen Layer f\u00fcr die Context Map. Dabei muss der Name folgender Konvention folgen: \" (BC) Appname \". In dem Layer legt man nun den/die BCs an, in dem man die Tabellen Komponente von MW benutzt. Es ist zu empfehlen immer nur ein BC abzubilden, auch wenn theoretisch mehrere m\u00f6glich sind, dient das der besseren \u00dcbersicht und Wiederverwendbarkeit Folgende Unterscheidungen existieren: 1) Aggregate Root (Farbe hellorange) 2) Child Entity (Farbe hellblau) 3) Value Object (Farbe rot) In den Kommentarfeldern bzw. Descriptionfeld der Tabellen Komponente muss der Bezug angegeben werden. Beim AR w\u00e4re es die Tabelle selbst. Bsp: Tabelle task: aggregate=Task; WICHTIG: Jede Kommentarfeld Definition MUSS mit einem Semikolon abgeschlossen werden, wenn eine Zuweisung mittels = erfolgt M\u00f6gliche Spalten-Definitionen: 1) readonly N\u00f6tig wenn kein CTC um dem Generator mitzuteilen, dass dieses Attribute nur im Query auftauchen, definiert werden darf 2) writeonly N\u00f6tig wenn kein CTC um dem Generator mitzuteilen, dass dieses Attribute nur im Command auftauchen, definiert werden darf 3) write und read Kombinierte Defintion von keiner Angabe readonly udn writeonly, dann taucht in beiden Command und Query das Attribute auf 4) noinit Erscheint nicht im Aggregate Konstruktor, Factory, oder Child-Method-Erzeugung 5) transition Wenn ein Enumfeld k\u00f6nnen hier die Zustands\u00fcberg\u00e4nge angegeben werden 6) nullable Attribute kann Null sein (Haken bei NN) 7) default Attribute default Wert (Eintrag bei Defaultspalte), hier ist eine Besonderheit zu beachten, wird ein Wert bei der Objekterzeugen als default vom Aggregate gesetzt muss ein default Wert hier stehen ansonsten darf kein default Wert verwendet werden (siehe Image). In dem Bild sieht man das Enumfeld Priority, welches per Api oder UI \u00fcbergeben werden muss (daher kein default Wert) und das Enumfeld state welches vom Aggregate, mit dem Wert 'OPEN' gesetzt wird, daher als default definiert. Damit der Code wie in dem Bild generiert werden kann, muss dieses Muster ber\u00fccksichtig werden. Bsp. (default): Bsp. (transition): Syntax: name: from -> to Bsp. (noinit und readonly): Value Objects Bei einem VO (rot) werden die immutables Attribute in die VO-Tabelle geschrieben und als Description wieder der Bezug zum AR hergestellt: Bsp: valueobject=Task In der AR-Tabelle wird als Spalte der Name des VOs aufgenommen mit unserem benutzerdefinierrten Typ ValueObject, das ist wichtig damit der Generator sp\u00e4ter entsprechend die xml-Files und Klassen erstellen kann Einzelne Attribute k\u00f6nnen \u00fcber das Kommentarfeld als readonly oder writeonly gesetzt werden. Wird nichts angegeben, werden beide Flags auf true gesetzt. Erstellen von Command und Query Timelines (optional) F\u00fcr die Timelines m\u00fcssen weitere Layer erzeugt werden, pro Timeline ein Layer. Dabei muss der Name folgender Konvention folgen: (CTC) Use Case Name. Die Timeline sollte die Zeitline des UseCases abbliden und nicht wahrlos die Tabellen darin platziert werden. In dem Layer legt man nun die CTCs an, in dem man die Tabellen Komponente von MW benutzt. Folgende Unterscheidungen existieren: 1) Command 2) Query Standard Use Cases 1) create 2) update 3) delete Existiert kein CTC werden einfach Standard Commands, Queries, Events und Handler generiert, also z.B. Commands: CreateTask, UpdateTask, DeleteTask Events: TaskCreated,TaskUpdated,TaskDeleted In dem Fall ist es dann wichtig mit den Attributen readonly und writeonly zu arbeiten. M\u00f6gliche Definitionen: 1) typ Gibt den Timelinetyp an [command,query] 2) aggregate Gibt den Bezug an 3) event Wenn keine ETC Timeline erw\u00fcnscht, kann hier das Event angegeben werden 4) resource Wenn kein Standard Use Case verwendet wird kann mit resource der Name gemapped werden, dass ist notwendig damit der Generator sp\u00e4ter den Command entsprechend der Resource Methode zuweisen kann [create,update,delete] 5) default Wert M\u00f6gliche Spalten-Definitionen: siehe BU-Model 1) reference Kann angegeben werden, um ein VO als BC-Grenzobjekt zu Kennzeichen, also was von einem anderem BC stammt, dadurch kann der Generator die entsprechende Code Logic im CommandHandler erzeugen (Inject Repository etc.) 2) generator Kann angegeben werden, um ein VO als Nummergenerator zu kennzeichnen, dadurch generiert der Generator die ensprechende Codelogik in den Repositories und den CommandHandlern (der Generator muss sp\u00e4ter im Core existieren) Bsp. (reference): Bsp. Code Commandhandler: Korrekte Zuordnung der Codegenerierung von Zeile 42-46 und 56,57 und 63 sind nur m\u00f6glich durch die Angabe des reference Attributes. Bsp. (generator): Code CommandHandler -> Generator (Zeile 50) Code Repository -> Generator Zusammenfassung In den Tabellen definiert man die jeweilgen Attribute als Spalten. Bei den Tabellen muss obligatorisch ein Typ im Kommentar bzw Description Feld eingetragen werden in der Form: typ=command f\u00fcr Command und typ=query f\u00fcr Query. Bei den Events muss eine zus\u00e4tzliche Angabe erfolgen und zwar der Bezug zum Command, wenn kein ETC existiert. Bsp: es gibt einen Command AddNewTask und ein Event NewTaskAdded , dann muss in dem Kommentarfeld des Commands, Semikolon getrennt, folgendes stehen: typ=command;aggregate=Task;event=NewTaskAdded;resource=create; . Erstellen von Event Timelines (optional) F\u00fcr die Timelines m\u00fcssen weitere Layer erzeugt werden, pro Timeline ein Layer. Dabei muss der Name folgender Konvention folgen: (ETC) Use Case Name. Die Timeline sollte die Zeitline des UseCases abbliden und nicht wahrlos die Tabellen darin platziert werden. In dem Layer legt man nun die ETCs an, in dem man die Tabellen Komponente von MW benutzt. Folgende Unterscheidungen existieren: 1) Event M\u00f6gliche Definitionen: 1) typ Gibt den Timelinetyp an [event] 2) aggregate Gibt den Bezug an (deprecated) 3) command Gibt den Bezug an 4) listeners Welche Aggregate sollen benachrichtigt werden (kommasepariert). Notwendig damit die entsprechenden Listener, in den BCs, generiert werden. In den Tabellen definiert man die jeweilgen Attribute als Spalten. Bei den Tabellen muss obligatorisch ein Typ im Kommentar bzw Description Feld eingetragen werden in der Form: typ=event f\u00fcr Event. Bei den Events muss eine zus\u00e4tzliche Angabe erfolgen und zwar der Bezug zum Command. Bsp: es gibt einen Command AddNewTask und ein Event NewTaskAdded , dann muss in dem Kommentarfeld des Events, Semikolon getrennt, folgendes stehen: typ=event;aggregate=Task;command=AddNewTask;listeners=Todo,Help; . Frontendentwicklung Durch Commands und Queries kann zus\u00e4tzlich die Frontendgenerierung gesteuert werden. M\u00f6gliche Definitionen (Query only): 1) component Angabe einer Vue-Komponente welche beim Generierungsprozess benutzt werden soll. M\u00f6gliche Spalten-Definitionen (Commands only): 1) inputType Der Typ des Formelements 2) group group=name gibt an das dieses Formelement in (name) als Accordion zusammengefasst wird 3) line Angabe welche Elemente horizontal in einer Zeile des Forms zusammengefasst werden k\u00f6nnen. M\u00f6gliche Input Types : text, textarea, date, datetime, time, select, switch, wysiwyg, number, slider, color, radio, checkbox Bsp: Per Angabe von name-6 kann in einem 24 Grid der Platz angegeben werden. Angenommen man m\u00f6chte in einer Zeile Vorname, Nachname unter dem Namen Name in der Group Allgemein haben und Ankunft und Abreise in einer Zeile unter der Group Extra , jeweils als col-6. Dann muss man den jeweiligen Attributen folgenderma\u00dfen definieren: Attribut firstname: group=General;line=name-6;inputType=text; Attribut surname: group=General;line=name-6;inputType=text; Attribut arrival: group=States;line=extras-6;inputType=date; Attribut departure: group=States;line=extras-6;inputType=date; Wird zu folgendem generiert: Troubleshoots 1) Leerstring im Json-File bei properties eigentlich nur bei ValueObject m\u00f6glich. Ursache ist wenn ValueObjects Tabellenname = dem Columnname ist. Bsp: ValueObject Tabelle hei\u00dft task_number, dann muss die Property \"number\" hei\u00dfen, also nicht \"task_number\", daher resultiert Punkt 2. 2) Identity VOs sind eine Ausnahme und m\u00fcssen/brauchen nicht dargestellt werden, da sie in der Aggregate Tabelle schon gekennzeichnet sind, wenn doch Benennung siehe Punkt 1.","title":"Introduction"},{"location":"developer/process/introduction/#development-process-erzeugung-eines-business-models","text":"","title":"Development Process (Erzeugung eines Business Models)"},{"location":"developer/process/introduction/#utensilien","text":"1) Mysql Workbench 2) Mysql Workbench Plugin \"Business-Model-Json-Generator\" 3) bumogen","title":"Utensilien"},{"location":"developer/process/introduction/#legende","text":"","title":"Legende"},{"location":"developer/process/introduction/#abkurzungen","text":"MW - Mysql Workbench BC - Bounded Context ETC - Event Timeline Context CTC - Command/Query Timeline Context BU - Business Model ER - Entity Relation AR - Aggregate Root VO - Value Object CE - Child Entity","title":"Abk\u00fcrzungen"},{"location":"developer/process/introduction/#was-muss-ich-vorab-tun","text":"1) Plugin installieren \u00fcber MW -> Scripting -> Install Plugin (das Plugin liegt im Projektverzeichnis unter dev/workbench_plugins 2) Benutzerdefiniertentyp ValueObject anlegen unter MW -> Model -> User Defined Types... mit dem Namen ValueObject rest ist egal.","title":"Was muss ich vorab tun?"},{"location":"developer/process/introduction/#erstellen-eines-bu-models-obligatorisch","text":"Nachdem anlegen eines Models in MW, erzeugt man zun\u00e4chst einen Layer f\u00fcr die Context Map. Dabei muss der Name folgender Konvention folgen: \" (BC) Appname \". In dem Layer legt man nun den/die BCs an, in dem man die Tabellen Komponente von MW benutzt. Es ist zu empfehlen immer nur ein BC abzubilden, auch wenn theoretisch mehrere m\u00f6glich sind, dient das der besseren \u00dcbersicht und Wiederverwendbarkeit Folgende Unterscheidungen existieren: 1) Aggregate Root (Farbe hellorange) 2) Child Entity (Farbe hellblau) 3) Value Object (Farbe rot) In den Kommentarfeldern bzw. Descriptionfeld der Tabellen Komponente muss der Bezug angegeben werden. Beim AR w\u00e4re es die Tabelle selbst. Bsp: Tabelle task: aggregate=Task; WICHTIG: Jede Kommentarfeld Definition MUSS mit einem Semikolon abgeschlossen werden, wenn eine Zuweisung mittels = erfolgt","title":"Erstellen eines BU-Models (obligatorisch)"},{"location":"developer/process/introduction/#mogliche-spalten-definitionen","text":"1) readonly N\u00f6tig wenn kein CTC um dem Generator mitzuteilen, dass dieses Attribute nur im Query auftauchen, definiert werden darf 2) writeonly N\u00f6tig wenn kein CTC um dem Generator mitzuteilen, dass dieses Attribute nur im Command auftauchen, definiert werden darf 3) write und read Kombinierte Defintion von keiner Angabe readonly udn writeonly, dann taucht in beiden Command und Query das Attribute auf 4) noinit Erscheint nicht im Aggregate Konstruktor, Factory, oder Child-Method-Erzeugung 5) transition Wenn ein Enumfeld k\u00f6nnen hier die Zustands\u00fcberg\u00e4nge angegeben werden 6) nullable Attribute kann Null sein (Haken bei NN) 7) default Attribute default Wert (Eintrag bei Defaultspalte), hier ist eine Besonderheit zu beachten, wird ein Wert bei der Objekterzeugen als default vom Aggregate gesetzt muss ein default Wert hier stehen ansonsten darf kein default Wert verwendet werden (siehe Image). In dem Bild sieht man das Enumfeld Priority, welches per Api oder UI \u00fcbergeben werden muss (daher kein default Wert) und das Enumfeld state welches vom Aggregate, mit dem Wert 'OPEN' gesetzt wird, daher als default definiert. Damit der Code wie in dem Bild generiert werden kann, muss dieses Muster ber\u00fccksichtig werden. Bsp. (default): Bsp. (transition): Syntax: name: from -> to Bsp. (noinit und readonly):","title":"M\u00f6gliche Spalten-Definitionen:"},{"location":"developer/process/introduction/#value-objects","text":"Bei einem VO (rot) werden die immutables Attribute in die VO-Tabelle geschrieben und als Description wieder der Bezug zum AR hergestellt: Bsp: valueobject=Task In der AR-Tabelle wird als Spalte der Name des VOs aufgenommen mit unserem benutzerdefinierrten Typ ValueObject, das ist wichtig damit der Generator sp\u00e4ter entsprechend die xml-Files und Klassen erstellen kann Einzelne Attribute k\u00f6nnen \u00fcber das Kommentarfeld als readonly oder writeonly gesetzt werden. Wird nichts angegeben, werden beide Flags auf true gesetzt.","title":"Value Objects"},{"location":"developer/process/introduction/#erstellen-von-command-und-query-timelines-optional","text":"F\u00fcr die Timelines m\u00fcssen weitere Layer erzeugt werden, pro Timeline ein Layer. Dabei muss der Name folgender Konvention folgen: (CTC) Use Case Name. Die Timeline sollte die Zeitline des UseCases abbliden und nicht wahrlos die Tabellen darin platziert werden. In dem Layer legt man nun die CTCs an, in dem man die Tabellen Komponente von MW benutzt. Folgende Unterscheidungen existieren: 1) Command 2) Query","title":"Erstellen von Command und Query Timelines (optional)"},{"location":"developer/process/introduction/#standard-use-cases","text":"1) create 2) update 3) delete Existiert kein CTC werden einfach Standard Commands, Queries, Events und Handler generiert, also z.B. Commands: CreateTask, UpdateTask, DeleteTask Events: TaskCreated,TaskUpdated,TaskDeleted In dem Fall ist es dann wichtig mit den Attributen readonly und writeonly zu arbeiten.","title":"Standard Use Cases"},{"location":"developer/process/introduction/#mogliche-definitionen","text":"1) typ Gibt den Timelinetyp an [command,query] 2) aggregate Gibt den Bezug an 3) event Wenn keine ETC Timeline erw\u00fcnscht, kann hier das Event angegeben werden 4) resource Wenn kein Standard Use Case verwendet wird kann mit resource der Name gemapped werden, dass ist notwendig damit der Generator sp\u00e4ter den Command entsprechend der Resource Methode zuweisen kann [create,update,delete] 5) default Wert","title":"M\u00f6gliche Definitionen:"},{"location":"developer/process/introduction/#mogliche-spalten-definitionen_1","text":"siehe BU-Model 1) reference Kann angegeben werden, um ein VO als BC-Grenzobjekt zu Kennzeichen, also was von einem anderem BC stammt, dadurch kann der Generator die entsprechende Code Logic im CommandHandler erzeugen (Inject Repository etc.) 2) generator Kann angegeben werden, um ein VO als Nummergenerator zu kennzeichnen, dadurch generiert der Generator die ensprechende Codelogik in den Repositories und den CommandHandlern (der Generator muss sp\u00e4ter im Core existieren) Bsp. (reference): Bsp. Code Commandhandler: Korrekte Zuordnung der Codegenerierung von Zeile 42-46 und 56,57 und 63 sind nur m\u00f6glich durch die Angabe des reference Attributes. Bsp. (generator):","title":"M\u00f6gliche Spalten-Definitionen:"},{"location":"developer/process/introduction/#code-commandhandler-generator-zeile-50","text":"","title":"Code CommandHandler -&gt; Generator (Zeile 50)"},{"location":"developer/process/introduction/#code-repository-generator","text":"","title":"Code Repository -&gt; Generator"},{"location":"developer/process/introduction/#zusammenfassung","text":"In den Tabellen definiert man die jeweilgen Attribute als Spalten. Bei den Tabellen muss obligatorisch ein Typ im Kommentar bzw Description Feld eingetragen werden in der Form: typ=command f\u00fcr Command und typ=query f\u00fcr Query. Bei den Events muss eine zus\u00e4tzliche Angabe erfolgen und zwar der Bezug zum Command, wenn kein ETC existiert. Bsp: es gibt einen Command AddNewTask und ein Event NewTaskAdded , dann muss in dem Kommentarfeld des Commands, Semikolon getrennt, folgendes stehen: typ=command;aggregate=Task;event=NewTaskAdded;resource=create; .","title":"Zusammenfassung"},{"location":"developer/process/introduction/#erstellen-von-event-timelines-optional","text":"F\u00fcr die Timelines m\u00fcssen weitere Layer erzeugt werden, pro Timeline ein Layer. Dabei muss der Name folgender Konvention folgen: (ETC) Use Case Name. Die Timeline sollte die Zeitline des UseCases abbliden und nicht wahrlos die Tabellen darin platziert werden. In dem Layer legt man nun die ETCs an, in dem man die Tabellen Komponente von MW benutzt. Folgende Unterscheidungen existieren: 1) Event","title":"Erstellen von Event Timelines (optional)"},{"location":"developer/process/introduction/#mogliche-definitionen_1","text":"1) typ Gibt den Timelinetyp an [event] 2) aggregate Gibt den Bezug an (deprecated) 3) command Gibt den Bezug an 4) listeners Welche Aggregate sollen benachrichtigt werden (kommasepariert). Notwendig damit die entsprechenden Listener, in den BCs, generiert werden. In den Tabellen definiert man die jeweilgen Attribute als Spalten. Bei den Tabellen muss obligatorisch ein Typ im Kommentar bzw Description Feld eingetragen werden in der Form: typ=event f\u00fcr Event. Bei den Events muss eine zus\u00e4tzliche Angabe erfolgen und zwar der Bezug zum Command. Bsp: es gibt einen Command AddNewTask und ein Event NewTaskAdded , dann muss in dem Kommentarfeld des Events, Semikolon getrennt, folgendes stehen: typ=event;aggregate=Task;command=AddNewTask;listeners=Todo,Help; .","title":"M\u00f6gliche Definitionen:"},{"location":"developer/process/introduction/#frontendentwicklung","text":"Durch Commands und Queries kann zus\u00e4tzlich die Frontendgenerierung gesteuert werden.","title":"Frontendentwicklung"},{"location":"developer/process/introduction/#mogliche-definitionen-query-only","text":"1) component Angabe einer Vue-Komponente welche beim Generierungsprozess benutzt werden soll.","title":"M\u00f6gliche Definitionen (Query only):"},{"location":"developer/process/introduction/#mogliche-spalten-definitionen-commands-only","text":"1) inputType Der Typ des Formelements 2) group group=name gibt an das dieses Formelement in (name) als Accordion zusammengefasst wird 3) line Angabe welche Elemente horizontal in einer Zeile des Forms zusammengefasst werden k\u00f6nnen. M\u00f6gliche Input Types : text, textarea, date, datetime, time, select, switch, wysiwyg, number, slider, color, radio, checkbox Bsp: Per Angabe von name-6 kann in einem 24 Grid der Platz angegeben werden. Angenommen man m\u00f6chte in einer Zeile Vorname, Nachname unter dem Namen Name in der Group Allgemein haben und Ankunft und Abreise in einer Zeile unter der Group Extra , jeweils als col-6. Dann muss man den jeweiligen Attributen folgenderma\u00dfen definieren: Attribut firstname: group=General;line=name-6;inputType=text; Attribut surname: group=General;line=name-6;inputType=text; Attribut arrival: group=States;line=extras-6;inputType=date; Attribut departure: group=States;line=extras-6;inputType=date; Wird zu folgendem generiert:","title":"M\u00f6gliche Spalten-Definitionen (Commands only):"},{"location":"developer/process/introduction/#troubleshoots","text":"1) Leerstring im Json-File bei properties eigentlich nur bei ValueObject m\u00f6glich. Ursache ist wenn ValueObjects Tabellenname = dem Columnname ist. Bsp: ValueObject Tabelle hei\u00dft task_number, dann muss die Property \"number\" hei\u00dfen, also nicht \"task_number\", daher resultiert Punkt 2. 2) Identity VOs sind eine Ausnahme und m\u00fcssen/brauchen nicht dargestellt werden, da sie in der Aggregate Tabelle schon gekennzeichnet sind, wenn doch Benennung siehe Punkt 1.","title":"Troubleshoots"},{"location":"operations/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Introduction"},{"location":"operations/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"operations/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"operations/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"project/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Introduction"},{"location":"project/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"project/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"project/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"project/backup/","text":"Server Backup Strategy The backup strategy is quite simple. A daily backup is created and downloaded by the Backup Tool . The backup files are stored on a NAS to get further backed up by the proprietary backup solution of the NAS. Description The Backup Tool is will be executed in agent mode by a cron job on the server. The tool itself is stored at /srv together with the configuration file, which contains the directories and databases to backup. The docker version of the Backup Tool runs in server mode at the NAS and connects to the server to download the packages. The connection is encrypted by SSH and secured by public/private key. The backup user is restricted to the backup directory. The tool creates packages of the directories and databases compressed by bzip2 . The packages are stored in /backup . The previously created packages will be replaced ( overwritten ). After the packages are created on the server the Backup Tool at the NAS connects to the server and downloads the packages to a local directory. After that the backup report is created and send to the configured receivers. The NAS backup solution provides restoring a daily version for the last 4 weeks and a weekly version for the last year. Timings 02:00 Packages are created at the server. 03:00 Packages are downloaded by the NAS from the server. 04:00 Packages are backed up by the NAS backup solution.","title":"Server Backup"},{"location":"project/backup/#server-backup","text":"","title":"Server Backup"},{"location":"project/backup/#strategy","text":"The backup strategy is quite simple. A daily backup is created and downloaded by the Backup Tool . The backup files are stored on a NAS to get further backed up by the proprietary backup solution of the NAS.","title":"Strategy"},{"location":"project/backup/#description","text":"The Backup Tool is will be executed in agent mode by a cron job on the server. The tool itself is stored at /srv together with the configuration file, which contains the directories and databases to backup. The docker version of the Backup Tool runs in server mode at the NAS and connects to the server to download the packages. The connection is encrypted by SSH and secured by public/private key. The backup user is restricted to the backup directory. The tool creates packages of the directories and databases compressed by bzip2 . The packages are stored in /backup . The previously created packages will be replaced ( overwritten ). After the packages are created on the server the Backup Tool at the NAS connects to the server and downloads the packages to a local directory. After that the backup report is created and send to the configured receivers. The NAS backup solution provides restoring a daily version for the last 4 weeks and a weekly version for the last year.","title":"Description"},{"location":"project/backup/#timings","text":"02:00 Packages are created at the server. 03:00 Packages are downloaded by the NAS from the server. 04:00 Packages are backed up by the NAS backup solution.","title":"Timings"}]}