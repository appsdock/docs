{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AppsDock OS Documentation This documentation is about the development of AppsDock, a PHP based enterprise platform for business applications. By reading this documentation you will learn the concept, composition and the development aspects of the AppsDock platform. You will be able to maintain, develop, adapt and extend the platform by writing apps, extension and plugins. Concept The AppsDock platform provides an universal foundation which is able to run a large scale of business apps.","title":"Introduction"},{"location":"#appsdock-os-documentation","text":"This documentation is about the development of AppsDock, a PHP based enterprise platform for business applications. By reading this documentation you will learn the concept, composition and the development aspects of the AppsDock platform. You will be able to maintain, develop, adapt and extend the platform by writing apps, extension and plugins.","title":"AppsDock OS Documentation"},{"location":"#concept","text":"The AppsDock platform provides an universal foundation which is able to run a large scale of business apps.","title":"Concept"},{"location":"gettingstarted/xdebug/","text":"Phpstorm Xdebug-Einrichtung Deployment-Konfiguration des Vagrant Box vollenden \u00dcberpr\u00fcfung der Einstellung siehe Screenshot Server einrichten Wichtig! Das Mapping Local-Path zu Remot Path (Bild Project Files) Debugkonfiguration Run -> Debug -> Edit Configurations -> Defaults aufklappen -> Php Remote Debug Dort den in Schritt2 erstellten Server ausw\u00e4hlen. Listening aktivieren Run -> Start Listening for Php Connections Dann Breakpoint setzen in Storm -> und Seite im Browser aufrufen et voila!!!","title":"XDebug"},{"location":"gettingstarted/xdebug/#phpstorm-xdebug-einrichtung","text":"Deployment-Konfiguration des Vagrant Box vollenden \u00dcberpr\u00fcfung der Einstellung siehe Screenshot","title":"Phpstorm Xdebug-Einrichtung"},{"location":"gettingstarted/xdebug/#server-einrichten","text":"Wichtig! Das Mapping Local-Path zu Remot Path (Bild Project Files)","title":"Server einrichten"},{"location":"gettingstarted/xdebug/#debugkonfiguration","text":"Run -> Debug -> Edit Configurations -> Defaults aufklappen -> Php Remote Debug Dort den in Schritt2 erstellten Server ausw\u00e4hlen.","title":"Debugkonfiguration"},{"location":"gettingstarted/xdebug/#listening-aktivieren","text":"Run -> Start Listening for Php Connections Dann Breakpoint setzen in Storm -> und Seite im Browser aufrufen et voila!!!","title":"Listening aktivieren"},{"location":"gettingstarted/api/rest/","text":"REST API Endpunkte Um f\u00fcr eine App eigene REST API Endpunkte zu erstellen, legt man eine Klasse an, welche vom AppsDock\\Core\\Contracts\\App\\Application\\RestAPIController erbt. In dieser werden \u00fcber Annotation Attribute die einzelnen Endpunkte definiert. Der Zugriff auf Endpunkte kann mittels Richtlinien abgesichert werden. Methoden class BookRestAPI extends RestAPIController { #[API('GET', '/books', 'book.list')] public function listBooks(): JsonResponse { ... } #[API('GET', '/books/{id}', 'book.get')] public function getBook(string $bookId): JsonResponse { ... } #[API('POST', '/books', 'book.create')] public function createBook(): JsonResponse { ... } #[API('DELETE', '/books/{id}', 'book.delete')] public function deleteBook(string $bookId): JsonResponse { ... } } Parameter Datentyp Standardwert Erforderlich Beschreibung 1 String|String[] - \u2714 Methoden: DELETE, GET, HEAD, PATCH, POST und PUT. 2 String - \u2714 Route: Valide URL. 3 String - \u2714 Eindeutiger Name in Domain-Schreibweise. 4 Integer 1 \u2718 API-Version. \u2714 Ja \u2718 Nein R\u00fcckgabewerte Der R\u00fcckgabewert eines Endpunkts muss immer vom Datentyp AppsDock\\Core\\Http\\JsonResponse sein. Um eine allgemeine R\u00fcckmeldung zu erzeugen, kann die Methode createResponse verwendet werden. $this->createResponse( int $statusCode = 200, array $data = [], array $headers = [] ); Soll ein HTTP-Status-Code zur\u00fcckgegeben werden, kann die Methode createStatusResponse verwendet werden. $this->createStatusResponse( int $statusCode, string $message = null, array $headers = [] ); Sollen Daten zur\u00fcckgegeben werden, kann die Methode createDataResponse verwendet werden. $this->createDataResponse( ReadModel|ReadModelCollection|null $data, int $statusCode = 200, array $headers = [] );","title":"REST"},{"location":"gettingstarted/api/rest/#rest-api","text":"","title":"REST API"},{"location":"gettingstarted/api/rest/#endpunkte","text":"Um f\u00fcr eine App eigene REST API Endpunkte zu erstellen, legt man eine Klasse an, welche vom AppsDock\\Core\\Contracts\\App\\Application\\RestAPIController erbt. In dieser werden \u00fcber Annotation Attribute die einzelnen Endpunkte definiert. Der Zugriff auf Endpunkte kann mittels Richtlinien abgesichert werden.","title":"Endpunkte"},{"location":"gettingstarted/api/rest/#methoden","text":"class BookRestAPI extends RestAPIController { #[API('GET', '/books', 'book.list')] public function listBooks(): JsonResponse { ... } #[API('GET', '/books/{id}', 'book.get')] public function getBook(string $bookId): JsonResponse { ... } #[API('POST', '/books', 'book.create')] public function createBook(): JsonResponse { ... } #[API('DELETE', '/books/{id}', 'book.delete')] public function deleteBook(string $bookId): JsonResponse { ... } } Parameter Datentyp Standardwert Erforderlich Beschreibung 1 String|String[] - \u2714 Methoden: DELETE, GET, HEAD, PATCH, POST und PUT. 2 String - \u2714 Route: Valide URL. 3 String - \u2714 Eindeutiger Name in Domain-Schreibweise. 4 Integer 1 \u2718 API-Version. \u2714 Ja \u2718 Nein","title":"Methoden"},{"location":"gettingstarted/api/rest/#ruckgabewerte","text":"Der R\u00fcckgabewert eines Endpunkts muss immer vom Datentyp AppsDock\\Core\\Http\\JsonResponse sein. Um eine allgemeine R\u00fcckmeldung zu erzeugen, kann die Methode createResponse verwendet werden. $this->createResponse( int $statusCode = 200, array $data = [], array $headers = [] ); Soll ein HTTP-Status-Code zur\u00fcckgegeben werden, kann die Methode createStatusResponse verwendet werden. $this->createStatusResponse( int $statusCode, string $message = null, array $headers = [] ); Sollen Daten zur\u00fcckgegeben werden, kann die Methode createDataResponse verwendet werden. $this->createDataResponse( ReadModel|ReadModelCollection|null $data, int $statusCode = 200, array $headers = [] );","title":"R\u00fcckgabewerte"},{"location":"gettingstarted/guidelines/version-control/","text":"Version control (Git) Repository Commit Messages A commit message must consist of the following parts: FunctionID This identifier should contain the project identifier. This project identifier are defined for each project / app in jira. ADK Identifier: CORE, DEV, SYS, ADK, FT, CM, DM * CORE = core folder * SYS = system folder * DEV = dev folder * FE = frontend folder * ADK = bin,www folder and all what is not suitable * CM = Configuration Management * DOC = Documentation Management Label Choose one of the labels that fits the change in your commit. #INIT \u2013 Initialize a new repo or release repro:documentation / configuration \u2026 archetype:jar / war / ear / pom / zip \u2026 version:version #IMPLEMENT \u2013 Implement a new Function, Class, Component or Use case function:clazz create:clazz / compontent use-case:usecaze #CHANGE \u2013 Change a exists function,class or component function:clazz refactor:clazz / function / component / use-case... #EXTEND \u2013 Extend a exists function,class or component function:clazz attach:clazz / component / use-case ... #BUGFIX priority:critical / medium / low / design #REVIEW \u2013 Quality refactor:function analyze:quality migrate:function format:source #RELEASE version:version #REVERT \u2013 Revert a Revision commit:id #BRANCH create:name stash:branch #MERGE from:branch to:branch #CLOSE branch:name Task-ID This ID is the issue ID generated by JIRA.","title":"Version Control"},{"location":"gettingstarted/guidelines/version-control/#version-control-git","text":"","title":"Version control (Git)"},{"location":"gettingstarted/guidelines/version-control/#repository-commit-messages","text":"A commit message must consist of the following parts: FunctionID This identifier should contain the project identifier. This project identifier are defined for each project / app in jira. ADK Identifier: CORE, DEV, SYS, ADK, FT, CM, DM * CORE = core folder * SYS = system folder * DEV = dev folder * FE = frontend folder * ADK = bin,www folder and all what is not suitable * CM = Configuration Management * DOC = Documentation Management Label Choose one of the labels that fits the change in your commit. #INIT \u2013 Initialize a new repo or release repro:documentation / configuration \u2026 archetype:jar / war / ear / pom / zip \u2026 version:version #IMPLEMENT \u2013 Implement a new Function, Class, Component or Use case function:clazz create:clazz / compontent use-case:usecaze #CHANGE \u2013 Change a exists function,class or component function:clazz refactor:clazz / function / component / use-case... #EXTEND \u2013 Extend a exists function,class or component function:clazz attach:clazz / component / use-case ... #BUGFIX priority:critical / medium / low / design #REVIEW \u2013 Quality refactor:function analyze:quality migrate:function format:source #RELEASE version:version #REVERT \u2013 Revert a Revision commit:id #BRANCH create:name stash:branch #MERGE from:branch to:branch #CLOSE branch:name Task-ID This ID is the issue ID generated by JIRA.","title":"Repository Commit Messages"},{"location":"identity-access/authentication/","text":"AppsDock Authentication Service The AppsDock application server provides a build in authentication and authorization service to secure the resources. This topic provides an overview how to authenticate and access secured resources of the application server. Basics The request of resources from AppsDock application server requires an access token from the AppsDock authentication service. To obtain an access token, there must be a registered auth client at AppsDock identity management which must be used when requesting the auth endpoints with client credentials from your web or app application. Auth Client The access of auth API endpoints requires at least one registered auth client at AppsDock identity management. The AppsDock identity management can register multiple auth client with different configurations which can be used by different applications. Each auth client has its own credentials (client id or client id with secret) which must be used when requesting the auth API. The credentials can be attached as basic base64 encoded Auhtorization header or as query parameter at request uri. Access token The access token is issued by the AppsDock authentication service and contains secured information (claims) about the actual operator. The token also contains information which are used to validate/authenticate the operator and verify that it has the required permissions / is authorized to perform the operation. Access tokens have to be attached to each request that intents to access secured resources of the AppsDock application server. The transport must be always over a secured channel like HTTPS. An access token issued by the AppsDock authentication service looks like the following example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c To attach the access token, you must set the access token as bearer type in the Authorization header. Authentication The AppsDock authentication service provides an API for token and cookie based authentication management which includes the following operations: Endpoint Operation /auth/token Authentication with email/username and password /auth/token/refresh Session/Token refresh via refresh token or cookie /auth/revoke Revoke auth session via refresh token or cookie The AppsDock authentication service supports both token and cookie based authentication flows. Token Based Auth The token based authentication is used by confidential clients like mobile apps, which are capable of storing the refresh token securely. To obtain an access and refresh token, you have to send a request with the auth client credentials as authorization header to the token endpoint. POST https : // domain . com / auth / token Content - Type : application / json Authrorization : Basic WIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF { \"email\" : \"jon@doe.com\" , \"password\" : \"xxxxx\" } The response contains the access/refresh token and additional information about the access token. { \"expires_in\" : 180 , \"expires_at\" : 1595453215 , \"token_type\" : \"bearer\" , \"access_token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0......\" , \"refresh_token\" : \"xwRJSMxNTE2MjMeKKF2QiwibmFtZSIfwpMeJf6Ik\" } The access token must be attached as bearer token in Authorization header on each request of secured resources. The refresh token is used to refresh the access token when it expires and obtain a new access token. Refresh token storage The refresh token must be stored securely and should not be accessible by the client user. Do not store the refresh token into any kind of client side storages of web applications like local or session store nor into cookies. Cookie Based Auth ...... doc comming { \"expires_in\" : 180 , \"expires_at\" : 1595453215 } A cookie based client response only the expiry information about the current auth session, and uses an secured httpsonly cookie to store the auth session information on client side. The auth cookie issued by the cookie based confidential client has also a short lifetime like the access token, so it must be refreshed to keep the auth session valid. Public clients Public auth clients are currently not supported by the AppsDock authentication service! Refreshing ..","title":"Authentication"},{"location":"identity-access/authentication/#appsdock-authentication-service","text":"The AppsDock application server provides a build in authentication and authorization service to secure the resources. This topic provides an overview how to authenticate and access secured resources of the application server.","title":"AppsDock Authentication Service"},{"location":"identity-access/authentication/#basics","text":"The request of resources from AppsDock application server requires an access token from the AppsDock authentication service. To obtain an access token, there must be a registered auth client at AppsDock identity management which must be used when requesting the auth endpoints with client credentials from your web or app application.","title":"Basics"},{"location":"identity-access/authentication/#auth-client","text":"The access of auth API endpoints requires at least one registered auth client at AppsDock identity management. The AppsDock identity management can register multiple auth client with different configurations which can be used by different applications. Each auth client has its own credentials (client id or client id with secret) which must be used when requesting the auth API. The credentials can be attached as basic base64 encoded Auhtorization header or as query parameter at request uri.","title":"Auth Client"},{"location":"identity-access/authentication/#access-token","text":"The access token is issued by the AppsDock authentication service and contains secured information (claims) about the actual operator. The token also contains information which are used to validate/authenticate the operator and verify that it has the required permissions / is authorized to perform the operation. Access tokens have to be attached to each request that intents to access secured resources of the AppsDock application server. The transport must be always over a secured channel like HTTPS. An access token issued by the AppsDock authentication service looks like the following example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c To attach the access token, you must set the access token as bearer type in the Authorization header.","title":"Access token"},{"location":"identity-access/authentication/#authentication","text":"The AppsDock authentication service provides an API for token and cookie based authentication management which includes the following operations: Endpoint Operation /auth/token Authentication with email/username and password /auth/token/refresh Session/Token refresh via refresh token or cookie /auth/revoke Revoke auth session via refresh token or cookie The AppsDock authentication service supports both token and cookie based authentication flows.","title":"Authentication"},{"location":"identity-access/authentication/#token-based-auth","text":"The token based authentication is used by confidential clients like mobile apps, which are capable of storing the refresh token securely. To obtain an access and refresh token, you have to send a request with the auth client credentials as authorization header to the token endpoint. POST https : // domain . com / auth / token Content - Type : application / json Authrorization : Basic WIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF { \"email\" : \"jon@doe.com\" , \"password\" : \"xxxxx\" } The response contains the access/refresh token and additional information about the access token. { \"expires_in\" : 180 , \"expires_at\" : 1595453215 , \"token_type\" : \"bearer\" , \"access_token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0......\" , \"refresh_token\" : \"xwRJSMxNTE2MjMeKKF2QiwibmFtZSIfwpMeJf6Ik\" } The access token must be attached as bearer token in Authorization header on each request of secured resources. The refresh token is used to refresh the access token when it expires and obtain a new access token. Refresh token storage The refresh token must be stored securely and should not be accessible by the client user. Do not store the refresh token into any kind of client side storages of web applications like local or session store nor into cookies.","title":"Token Based Auth"},{"location":"identity-access/authentication/#cookie-based-auth","text":"...... doc comming { \"expires_in\" : 180 , \"expires_at\" : 1595453215 } A cookie based client response only the expiry information about the current auth session, and uses an secured httpsonly cookie to store the auth session information on client side. The auth cookie issued by the cookie based confidential client has also a short lifetime like the access token, so it must be refreshed to keep the auth session valid. Public clients Public auth clients are currently not supported by the AppsDock authentication service!","title":"Cookie Based Auth"},{"location":"identity-access/authentication/#refreshing","text":"..","title":"Refreshing"},{"location":"identity-access/identity/","text":"Identit\u00e4ten Zu den Identit\u00e4ten z\u00e4hlen Benutzer, Gruppen und Rollen. Benutzer Der Benutzer wird f\u00fcr die Identifizierung und Autorisierung einer Entit\u00e4t verwendet. Gruppen Benutzer k\u00f6nnen zu einer Gruppe zusammengefasst werden. Ein Benutzer kann mehreren Gruppen angeh\u00f6ren. Durch eine Gruppe k\u00f6nnen mehreren Benutzern Rollen zugewiesen werden. Rollen Rollen sind Identit\u00e4ten, welche Benutzern und Gruppen zugewiesen werden k\u00f6nnen. Mittels der Rolle werden die Berechtigungen identifiziert. Einer Rolle k\u00f6nnen eine oder mehrere Richtlinien zugewiesen werden.","title":"Identity"},{"location":"identity-access/identity/#identitaten","text":"Zu den Identit\u00e4ten z\u00e4hlen Benutzer, Gruppen und Rollen.","title":"Identit\u00e4ten"},{"location":"identity-access/identity/#benutzer","text":"Der Benutzer wird f\u00fcr die Identifizierung und Autorisierung einer Entit\u00e4t verwendet.","title":"Benutzer"},{"location":"identity-access/identity/#gruppen","text":"Benutzer k\u00f6nnen zu einer Gruppe zusammengefasst werden. Ein Benutzer kann mehreren Gruppen angeh\u00f6ren. Durch eine Gruppe k\u00f6nnen mehreren Benutzern Rollen zugewiesen werden.","title":"Gruppen"},{"location":"identity-access/identity/#rollen","text":"Rollen sind Identit\u00e4ten, welche Benutzern und Gruppen zugewiesen werden k\u00f6nnen. Mittels der Rolle werden die Berechtigungen identifiziert. Einer Rolle k\u00f6nnen eine oder mehrere Richtlinien zugewiesen werden.","title":"Rollen"},{"location":"identity-access/policies/","text":"Richtlinien und Berechtigungen Berechtigung Eine Berechtigung besteht aus einer oder mehreren Richtlinien. Beispiel: Die Berechtigung DMS-Anwender hat das unbestimmte Recht innerhalb des gesamten DMS zu lesen und das bestimmte Recht in den eigenen Ordnern zu schreiben. Richtlinie Aktion Rolle Ressource Effekt Lesen com.appsdock.dms.action:read UUID * ALLOW Schreiben com.appsdock.dms.action:write UUID UUID ALLOW Richtlinie Eine Richtlinie besteht aus der Aktion, der Rolle, der Ressource und dem Effekt. Aktion Aktionen werden von den Apps definiert. Beispiel: Die DMS-App definiert die Aktion Ordner anlegen . Rolle Pro Richtlinie muss exakt eine Rolle zugewiesen werden. Ressource Eine Ressource kann bestimmt oder unbestimmt sein. Unbestimmte Ressourcen werden mittels des * definiert. Effekt Der Effekt ist entweder Erlauben oder Verbieten . Berechtigungssteuerung Der Berechtigungssteuerung wird die Aktion als erster Parameter und der Kontext als zweiter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId() ); Bei einer bestimmten Ressource wird deren UUID als dritter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId ); Alternativ kann ein Standardwert als vierter Parameter angegeben werden. Dieser wird nur zur\u00fcckgegeben, wenn keine Richtlinie existiert. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId, $default ); REST API Berechtigungen werden als Methoden-Attribut oder alternativ als Klassen-Attribut definiert. Berechtigungen als Klassen-Attribut gelten f\u00fcr alle Funktionen innerhalb der Klasse. Unbestimmte Ressource #[Permission('read')] Bestimmte Ressource \u00dcber den zweiten Parameter kann die UUID der Ressource angegeben werden. Die UUID kann bspw. im Kontext der REST API mittels eines Routing-Parameters dynamisch \u00fcbergeben werden. #[Permission('read', 'id')] Alternativer Kontext \u00dcber den dritten Parameter kann ein alternativer Kontext angegeben werden, damit man Richtlinien aus anderen Apps pr\u00fcfen kann. #[Permission('read', 'id', 'com.appsdock')] Mehrere Richtlinien Mehrere Richtlinien k\u00f6nnen direkt als Array \u00fcbergeben werden. #[Permission(['read', 'write', 'delete'])] Bei bestimmten Ressourcen oder einem alternativen Kontext m\u00fcssen diese separat aufgef\u00fchrt werden. #[Permission(['read', 'write'])] #[Permission('delete', 'id')] #[Permission('administrate', context: 'com.appsdock')] Klassen-Attribut #[Permission('read')] class DMS { ... } Methoden-Attribut #[Permission('write')] public function write(string $text): bool { ... } Sonderfall: \u00f6ffentlicher Zugriff Der \u00f6ffentliche Zugriff auf Klassen-Ebene kann von Richtlinien auf Methoden-Ebene \u00fcberschrieben werden. Wiederum ignoriert der \u00f6ffentliche Zugriff auf Methoden-Ebene alle zus\u00e4tzlichen Richtlinien. #[PublicAccess]","title":"Policy"},{"location":"identity-access/policies/#richtlinien-und-berechtigungen","text":"","title":"Richtlinien und Berechtigungen"},{"location":"identity-access/policies/#berechtigung","text":"Eine Berechtigung besteht aus einer oder mehreren Richtlinien. Beispiel: Die Berechtigung DMS-Anwender hat das unbestimmte Recht innerhalb des gesamten DMS zu lesen und das bestimmte Recht in den eigenen Ordnern zu schreiben. Richtlinie Aktion Rolle Ressource Effekt Lesen com.appsdock.dms.action:read UUID * ALLOW Schreiben com.appsdock.dms.action:write UUID UUID ALLOW","title":"Berechtigung"},{"location":"identity-access/policies/#richtlinie","text":"Eine Richtlinie besteht aus der Aktion, der Rolle, der Ressource und dem Effekt.","title":"Richtlinie"},{"location":"identity-access/policies/#aktion","text":"Aktionen werden von den Apps definiert. Beispiel: Die DMS-App definiert die Aktion Ordner anlegen .","title":"Aktion"},{"location":"identity-access/policies/#rolle","text":"Pro Richtlinie muss exakt eine Rolle zugewiesen werden.","title":"Rolle"},{"location":"identity-access/policies/#ressource","text":"Eine Ressource kann bestimmt oder unbestimmt sein. Unbestimmte Ressourcen werden mittels des * definiert.","title":"Ressource"},{"location":"identity-access/policies/#effekt","text":"Der Effekt ist entweder Erlauben oder Verbieten .","title":"Effekt"},{"location":"identity-access/policies/#berechtigungssteuerung","text":"Der Berechtigungssteuerung wird die Aktion als erster Parameter und der Kontext als zweiter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId() ); Bei einer bestimmten Ressource wird deren UUID als dritter Parameter angegeben. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId ); Alternativ kann ein Standardwert als vierter Parameter angegeben werden. Dieser wird nur zur\u00fcckgegeben, wenn keine Richtlinie existiert. $isPermitted = $this->permissionController->isPermitted( 'read', $this->context->getId(), $appId, $default );","title":"Berechtigungssteuerung"},{"location":"identity-access/policies/#rest-api","text":"Berechtigungen werden als Methoden-Attribut oder alternativ als Klassen-Attribut definiert. Berechtigungen als Klassen-Attribut gelten f\u00fcr alle Funktionen innerhalb der Klasse.","title":"REST API"},{"location":"identity-access/policies/#unbestimmte-ressource","text":"#[Permission('read')]","title":"Unbestimmte Ressource"},{"location":"identity-access/policies/#bestimmte-ressource","text":"\u00dcber den zweiten Parameter kann die UUID der Ressource angegeben werden. Die UUID kann bspw. im Kontext der REST API mittels eines Routing-Parameters dynamisch \u00fcbergeben werden. #[Permission('read', 'id')]","title":"Bestimmte Ressource"},{"location":"identity-access/policies/#alternativer-kontext","text":"\u00dcber den dritten Parameter kann ein alternativer Kontext angegeben werden, damit man Richtlinien aus anderen Apps pr\u00fcfen kann. #[Permission('read', 'id', 'com.appsdock')]","title":"Alternativer Kontext"},{"location":"identity-access/policies/#mehrere-richtlinien","text":"Mehrere Richtlinien k\u00f6nnen direkt als Array \u00fcbergeben werden. #[Permission(['read', 'write', 'delete'])] Bei bestimmten Ressourcen oder einem alternativen Kontext m\u00fcssen diese separat aufgef\u00fchrt werden. #[Permission(['read', 'write'])] #[Permission('delete', 'id')] #[Permission('administrate', context: 'com.appsdock')]","title":"Mehrere Richtlinien"},{"location":"identity-access/policies/#klassen-attribut","text":"#[Permission('read')] class DMS { ... }","title":"Klassen-Attribut"},{"location":"identity-access/policies/#methoden-attribut","text":"#[Permission('write')] public function write(string $text): bool { ... }","title":"Methoden-Attribut"},{"location":"identity-access/policies/#sonderfall-offentlicher-zugriff","text":"Der \u00f6ffentliche Zugriff auf Klassen-Ebene kann von Richtlinien auf Methoden-Ebene \u00fcberschrieben werden. Wiederum ignoriert der \u00f6ffentliche Zugriff auf Methoden-Ebene alle zus\u00e4tzlichen Richtlinien. #[PublicAccess]","title":"Sonderfall: \u00f6ffentlicher Zugriff"}]}